// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "storage/chart.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace chart_proto {

namespace {

const ::google::protobuf::Descriptor* Color_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Color_reflection_ = NULL;
const ::google::protobuf::Descriptor* Style_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Style_reflection_ = NULL;
const ::google::protobuf::Descriptor* Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Point_reflection_ = NULL;
const ::google::protobuf::Descriptor* Line_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Line_reflection_ = NULL;
const ::google::protobuf::Descriptor* Rectangle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Rectangle_reflection_ = NULL;
const ::google::protobuf::Descriptor* Circle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Circle_reflection_ = NULL;
const ::google::protobuf::Descriptor* Polygon_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Polygon_reflection_ = NULL;
const ::google::protobuf::Descriptor* Spline_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Spline_reflection_ = NULL;
const ::google::protobuf::Descriptor* Text_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Text_reflection_ = NULL;
const ::google::protobuf::Descriptor* Shape_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Shape_reflection_ = NULL;
const ::google::protobuf::Descriptor* Graphic_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Graphic_reflection_ = NULL;
const ::google::protobuf::Descriptor* Action_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Action_reflection_ = NULL;
const ::google::protobuf::Descriptor* Row_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Row_reflection_ = NULL;
const ::google::protobuf::Descriptor* ActionType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ActionType_reflection_ = NULL;
const ::google::protobuf::Descriptor* Library_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Library_reflection_ = NULL;
const ::google::protobuf::Descriptor* Chart_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Chart_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChartFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChartFile_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_storage_2fchart_2eproto() {
  protobuf_AddDesc_storage_2fchart_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "storage/chart.proto");
  GOOGLE_CHECK(file != NULL);
  Color_descriptor_ = file->message_type(0);
  static const int Color_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, red_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, green_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, blue_),
  };
  Color_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Color_descriptor_,
      Color::default_instance_,
      Color_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Color));
  Style_descriptor_ = file->message_type(1);
  static const int Style_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Style, fill_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Style, stroke_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Style, stroke_width_),
  };
  Style_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Style_descriptor_,
      Style::default_instance_,
      Style_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Style, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Style, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Style));
  Point_descriptor_ = file->message_type(2);
  static const int Point_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, y_),
  };
  Point_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Point_descriptor_,
      Point::default_instance_,
      Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Point));
  Line_descriptor_ = file->message_type(3);
  static const int Line_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, point1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, point2_),
  };
  Line_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Line_descriptor_,
      Line::default_instance_,
      Line_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Line));
  Rectangle_descriptor_ = file->message_type(4);
  static const int Rectangle_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rectangle, top_left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rectangle, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rectangle, height_),
  };
  Rectangle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Rectangle_descriptor_,
      Rectangle::default_instance_,
      Rectangle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rectangle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rectangle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Rectangle));
  Circle_descriptor_ = file->message_type(5);
  static const int Circle_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Circle, center_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Circle, radius_),
  };
  Circle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Circle_descriptor_,
      Circle::default_instance_,
      Circle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Circle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Circle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Circle));
  Polygon_descriptor_ = file->message_type(6);
  static const int Polygon_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, point_),
  };
  Polygon_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Polygon_descriptor_,
      Polygon::default_instance_,
      Polygon_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Polygon));
  Spline_descriptor_ = file->message_type(7);
  static const int Spline_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spline, point_),
  };
  Spline_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Spline_descriptor_,
      Spline::default_instance_,
      Spline_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spline, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spline, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Spline));
  Text_descriptor_ = file->message_type(8);
  static const int Text_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Text, point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Text, text_),
  };
  Text_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Text_descriptor_,
      Text::default_instance_,
      Text_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Text, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Text, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Text));
  Shape_descriptor_ = file->message_type(9);
  static const int Shape_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, line_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, rectangle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, circle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, polygon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, spline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, style_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, text_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, text_length_),
  };
  Shape_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Shape_descriptor_,
      Shape::default_instance_,
      Shape_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Shape, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Shape));
  Graphic_descriptor_ = file->message_type(10);
  static const int Graphic_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graphic, shape_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graphic, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graphic, height_),
  };
  Graphic_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Graphic_descriptor_,
      Graphic::default_instance_,
      Graphic_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graphic, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Graphic, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Graphic));
  Action_descriptor_ = file->message_type(11);
  static const int Action_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, action_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, repetitions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, text_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, text_length_),
  };
  Action_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Action_descriptor_,
      Action::default_instance_,
      Action_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Action));
  Row_descriptor_ = file->message_type(12);
  static const int Row_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Row, action_),
  };
  Row_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Row_descriptor_,
      Row::default_instance_,
      Row_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Row, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Row, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Row));
  ActionType_descriptor_ = file->message_type(13);
  static const int ActionType_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ActionType, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ActionType, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ActionType, graphic_),
  };
  ActionType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ActionType_descriptor_,
      ActionType::default_instance_,
      ActionType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ActionType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ActionType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ActionType));
  Library_descriptor_ = file->message_type(14);
  static const int Library_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Library, action_type_),
  };
  Library_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Library_descriptor_,
      Library::default_instance_,
      Library_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Library, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Library, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Library));
  Chart_descriptor_ = file->message_type(15);
  static const int Chart_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chart, row_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chart, library_),
  };
  Chart_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Chart_descriptor_,
      Chart::default_instance_,
      Chart_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chart, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chart, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Chart));
  ChartFile_descriptor_ = file->message_type(16);
  static const int ChartFile_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChartFile, library_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChartFile, text_),
  };
  ChartFile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChartFile_descriptor_,
      ChartFile::default_instance_,
      ChartFile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChartFile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChartFile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChartFile));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_storage_2fchart_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Color_descriptor_, &Color::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Style_descriptor_, &Style::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Point_descriptor_, &Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Line_descriptor_, &Line::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Rectangle_descriptor_, &Rectangle::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Circle_descriptor_, &Circle::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Polygon_descriptor_, &Polygon::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Spline_descriptor_, &Spline::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Text_descriptor_, &Text::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Shape_descriptor_, &Shape::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Graphic_descriptor_, &Graphic::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Action_descriptor_, &Action::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Row_descriptor_, &Row::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ActionType_descriptor_, &ActionType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Library_descriptor_, &Library::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Chart_descriptor_, &Chart::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChartFile_descriptor_, &ChartFile::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_storage_2fchart_2eproto() {
  delete Color::default_instance_;
  delete Color_reflection_;
  delete Style::default_instance_;
  delete Style_reflection_;
  delete Point::default_instance_;
  delete Point_reflection_;
  delete Line::default_instance_;
  delete Line_reflection_;
  delete Rectangle::default_instance_;
  delete Rectangle_reflection_;
  delete Circle::default_instance_;
  delete Circle_reflection_;
  delete Polygon::default_instance_;
  delete Polygon_reflection_;
  delete Spline::default_instance_;
  delete Spline_reflection_;
  delete Text::default_instance_;
  delete Text_reflection_;
  delete Shape::default_instance_;
  delete Shape_reflection_;
  delete Graphic::default_instance_;
  delete Graphic_reflection_;
  delete Action::default_instance_;
  delete Action_reflection_;
  delete Row::default_instance_;
  delete Row_reflection_;
  delete ActionType::default_instance_;
  delete ActionType_reflection_;
  delete Library::default_instance_;
  delete Library_reflection_;
  delete Chart::default_instance_;
  delete Chart_reflection_;
  delete ChartFile::default_instance_;
  delete ChartFile_reflection_;
}

void protobuf_AddDesc_storage_2fchart_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023storage/chart.proto\022\013chart_proto\"1\n\005Co"
    "lor\022\013\n\003red\030\001 \002(\005\022\r\n\005green\030\002 \002(\005\022\014\n\004blue\030"
    "\003 \002(\005\"f\n\005Style\022 \n\004fill\030\001 \001(\0132\022.chart_pro"
    "to.Color\022\"\n\006stroke\030\002 \001(\0132\022.chart_proto.C"
    "olor\022\027\n\014stroke_width\030\003 \001(\005:\0011\"\035\n\005Point\022\t"
    "\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\"N\n\004Line\022\"\n\006point1\030\001"
    " \002(\0132\022.chart_proto.Point\022\"\n\006point2\030\002 \002(\013"
    "2\022.chart_proto.Point\"P\n\tRectangle\022$\n\010top"
    "_left\030\001 \002(\0132\022.chart_proto.Point\022\r\n\005width"
    "\030\002 \002(\002\022\016\n\006height\030\003 \002(\002\"<\n\006Circle\022\"\n\006cent"
    "er\030\001 \002(\0132\022.chart_proto.Point\022\016\n\006radius\030\002"
    " \002(\002\",\n\007Polygon\022!\n\005point\030\001 \003(\0132\022.chart_p"
    "roto.Point\"+\n\006Spline\022!\n\005point\030\001 \003(\0132\022.ch"
    "art_proto.Point\"7\n\004Text\022!\n\005point\030\001 \001(\0132\022"
    ".chart_proto.Point\022\014\n\004text\030\002 \002(\t\"\262\002\n\005Sha"
    "pe\022\037\n\004line\030\001 \001(\0132\021.chart_proto.Line\022)\n\tr"
    "ectangle\030\002 \001(\0132\026.chart_proto.Rectangle\022#"
    "\n\006circle\030\003 \001(\0132\023.chart_proto.Circle\022%\n\007p"
    "olygon\030\004 \001(\0132\024.chart_proto.Polygon\022#\n\006sp"
    "line\030\t \001(\0132\023.chart_proto.Spline\022\037\n\004text\030"
    "\010 \001(\0132\021.chart_proto.Text\022!\n\005style\030\005 \001(\0132"
    "\022.chart_proto.Style\022\023\n\013text_offset\030\006 \001(\005"
    "\022\023\n\013text_length\030\007 \001(\005\"K\n\007Graphic\022!\n\005shap"
    "e\030\001 \003(\0132\022.chart_proto.Shape\022\r\n\005width\030\002 \001"
    "(\002\022\016\n\006height\030\003 \001(\002\"i\n\006Action\022\016\n\006action\030\001"
    " \002(\t\022\r\n\005width\030\003 \002(\005\022\026\n\013repetitions\030\002 \001(\005"
    ":\0011\022\023\n\013text_offset\030\004 \001(\005\022\023\n\013text_length\030"
    "\005 \001(\005\"*\n\003Row\022#\n\006action\030\001 \003(\0132\023.chart_pro"
    "to.Action\"S\n\nActionType\022\014\n\004name\030\001 \002(\t\022\020\n"
    "\005width\030\002 \001(\005:\0011\022%\n\007graphic\030\004 \001(\0132\024.chart"
    "_proto.Graphic\"7\n\007Library\022,\n\013action_type"
    "\030\001 \003(\0132\027.chart_proto.ActionType\"M\n\005Chart"
    "\022\035\n\003row\030\001 \003(\0132\020.chart_proto.Row\022%\n\007libra"
    "ry\030\002 \001(\0132\024.chart_proto.Library\"@\n\tChartF"
    "ile\022%\n\007library\030\002 \001(\0132\024.chart_proto.Libra"
    "ry\022\014\n\004text\030\004 \001(\t", 1416);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "storage/chart.proto", &protobuf_RegisterTypes);
  Color::default_instance_ = new Color();
  Style::default_instance_ = new Style();
  Point::default_instance_ = new Point();
  Line::default_instance_ = new Line();
  Rectangle::default_instance_ = new Rectangle();
  Circle::default_instance_ = new Circle();
  Polygon::default_instance_ = new Polygon();
  Spline::default_instance_ = new Spline();
  Text::default_instance_ = new Text();
  Shape::default_instance_ = new Shape();
  Graphic::default_instance_ = new Graphic();
  Action::default_instance_ = new Action();
  Row::default_instance_ = new Row();
  ActionType::default_instance_ = new ActionType();
  Library::default_instance_ = new Library();
  Chart::default_instance_ = new Chart();
  ChartFile::default_instance_ = new ChartFile();
  Color::default_instance_->InitAsDefaultInstance();
  Style::default_instance_->InitAsDefaultInstance();
  Point::default_instance_->InitAsDefaultInstance();
  Line::default_instance_->InitAsDefaultInstance();
  Rectangle::default_instance_->InitAsDefaultInstance();
  Circle::default_instance_->InitAsDefaultInstance();
  Polygon::default_instance_->InitAsDefaultInstance();
  Spline::default_instance_->InitAsDefaultInstance();
  Text::default_instance_->InitAsDefaultInstance();
  Shape::default_instance_->InitAsDefaultInstance();
  Graphic::default_instance_->InitAsDefaultInstance();
  Action::default_instance_->InitAsDefaultInstance();
  Row::default_instance_->InitAsDefaultInstance();
  ActionType::default_instance_->InitAsDefaultInstance();
  Library::default_instance_->InitAsDefaultInstance();
  Chart::default_instance_->InitAsDefaultInstance();
  ChartFile::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_storage_2fchart_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_storage_2fchart_2eproto {
  StaticDescriptorInitializer_storage_2fchart_2eproto() {
    protobuf_AddDesc_storage_2fchart_2eproto();
  }
} static_descriptor_initializer_storage_2fchart_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Color::kRedFieldNumber;
const int Color::kGreenFieldNumber;
const int Color::kBlueFieldNumber;
#endif  // !_MSC_VER

Color::Color()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Color::InitAsDefaultInstance() {
}

Color::Color(const Color& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Color::SharedCtor() {
  _cached_size_ = 0;
  red_ = 0;
  green_ = 0;
  blue_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Color::~Color() {
  SharedDtor();
}

void Color::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Color::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Color::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Color_descriptor_;
}

const Color& Color::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Color* Color::default_instance_ = NULL;

Color* Color::New() const {
  return new Color;
}

void Color::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    red_ = 0;
    green_ = 0;
    blue_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Color::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 red = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &red_)));
          set_has_red();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_green;
        break;
      }
      
      // required int32 green = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_green:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &green_)));
          set_has_green();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_blue;
        break;
      }
      
      // required int32 blue = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blue_)));
          set_has_blue();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Color::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 red = 1;
  if (has_red()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->red(), output);
  }
  
  // required int32 green = 2;
  if (has_green()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->green(), output);
  }
  
  // required int32 blue = 3;
  if (has_blue()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->blue(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Color::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 red = 1;
  if (has_red()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->red(), target);
  }
  
  // required int32 green = 2;
  if (has_green()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->green(), target);
  }
  
  // required int32 blue = 3;
  if (has_blue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->blue(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Color::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 red = 1;
    if (has_red()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->red());
    }
    
    // required int32 green = 2;
    if (has_green()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->green());
    }
    
    // required int32 blue = 3;
    if (has_blue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->blue());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Color::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Color* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Color*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Color::MergeFrom(const Color& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_red()) {
      set_red(from.red());
    }
    if (from.has_green()) {
      set_green(from.green());
    }
    if (from.has_blue()) {
      set_blue(from.blue());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Color::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Color::CopyFrom(const Color& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Color::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Color::Swap(Color* other) {
  if (other != this) {
    std::swap(red_, other->red_);
    std::swap(green_, other->green_);
    std::swap(blue_, other->blue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Color::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Color_descriptor_;
  metadata.reflection = Color_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Style::kFillFieldNumber;
const int Style::kStrokeFieldNumber;
const int Style::kStrokeWidthFieldNumber;
#endif  // !_MSC_VER

Style::Style()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Style::InitAsDefaultInstance() {
  fill_ = const_cast< ::chart_proto::Color*>(&::chart_proto::Color::default_instance());
  stroke_ = const_cast< ::chart_proto::Color*>(&::chart_proto::Color::default_instance());
}

Style::Style(const Style& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Style::SharedCtor() {
  _cached_size_ = 0;
  fill_ = NULL;
  stroke_ = NULL;
  stroke_width_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Style::~Style() {
  SharedDtor();
}

void Style::SharedDtor() {
  if (this != default_instance_) {
    delete fill_;
    delete stroke_;
  }
}

void Style::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Style::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Style_descriptor_;
}

const Style& Style::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Style* Style::default_instance_ = NULL;

Style* Style::New() const {
  return new Style;
}

void Style::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_fill()) {
      if (fill_ != NULL) fill_->::chart_proto::Color::Clear();
    }
    if (has_stroke()) {
      if (stroke_ != NULL) stroke_->::chart_proto::Color::Clear();
    }
    stroke_width_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Style::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .chart_proto.Color fill = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fill()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_stroke;
        break;
      }
      
      // optional .chart_proto.Color stroke = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stroke:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stroke()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_stroke_width;
        break;
      }
      
      // optional int32 stroke_width = 3 [default = 1];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stroke_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stroke_width_)));
          set_has_stroke_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Style::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .chart_proto.Color fill = 1;
  if (has_fill()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->fill(), output);
  }
  
  // optional .chart_proto.Color stroke = 2;
  if (has_stroke()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->stroke(), output);
  }
  
  // optional int32 stroke_width = 3 [default = 1];
  if (has_stroke_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->stroke_width(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Style::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .chart_proto.Color fill = 1;
  if (has_fill()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->fill(), target);
  }
  
  // optional .chart_proto.Color stroke = 2;
  if (has_stroke()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->stroke(), target);
  }
  
  // optional int32 stroke_width = 3 [default = 1];
  if (has_stroke_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->stroke_width(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Style::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .chart_proto.Color fill = 1;
    if (has_fill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fill());
    }
    
    // optional .chart_proto.Color stroke = 2;
    if (has_stroke()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stroke());
    }
    
    // optional int32 stroke_width = 3 [default = 1];
    if (has_stroke_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stroke_width());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Style::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Style* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Style*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Style::MergeFrom(const Style& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fill()) {
      mutable_fill()->::chart_proto::Color::MergeFrom(from.fill());
    }
    if (from.has_stroke()) {
      mutable_stroke()->::chart_proto::Color::MergeFrom(from.stroke());
    }
    if (from.has_stroke_width()) {
      set_stroke_width(from.stroke_width());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Style::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Style::CopyFrom(const Style& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Style::IsInitialized() const {
  
  if (has_fill()) {
    if (!this->fill().IsInitialized()) return false;
  }
  if (has_stroke()) {
    if (!this->stroke().IsInitialized()) return false;
  }
  return true;
}

void Style::Swap(Style* other) {
  if (other != this) {
    std::swap(fill_, other->fill_);
    std::swap(stroke_, other->stroke_);
    std::swap(stroke_width_, other->stroke_width_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Style::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Style_descriptor_;
  metadata.reflection = Style_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Point::kXFieldNumber;
const int Point::kYFieldNumber;
#endif  // !_MSC_VER

Point::Point()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Point::InitAsDefaultInstance() {
}

Point::Point(const Point& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Point::~Point() {
  SharedDtor();
}

void Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Point_descriptor_;
}

const Point& Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Point* Point::default_instance_ = NULL;

Point* Point::New() const {
  return new Point;
}

void Point::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }
      
      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }
  
  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Point::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }
  
  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Point::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }
    
    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Point* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Point*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Point::MergeFrom(const Point& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Point::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point::CopyFrom(const Point& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Point::Swap(Point* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Point_descriptor_;
  metadata.reflection = Point_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Line::kPoint1FieldNumber;
const int Line::kPoint2FieldNumber;
#endif  // !_MSC_VER

Line::Line()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Line::InitAsDefaultInstance() {
  point1_ = const_cast< ::chart_proto::Point*>(&::chart_proto::Point::default_instance());
  point2_ = const_cast< ::chart_proto::Point*>(&::chart_proto::Point::default_instance());
}

Line::Line(const Line& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Line::SharedCtor() {
  _cached_size_ = 0;
  point1_ = NULL;
  point2_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Line::~Line() {
  SharedDtor();
}

void Line::SharedDtor() {
  if (this != default_instance_) {
    delete point1_;
    delete point2_;
  }
}

void Line::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Line::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Line_descriptor_;
}

const Line& Line::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Line* Line::default_instance_ = NULL;

Line* Line::New() const {
  return new Line;
}

void Line::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_point1()) {
      if (point1_ != NULL) point1_->::chart_proto::Point::Clear();
    }
    if (has_point2()) {
      if (point2_ != NULL) point2_->::chart_proto::Point::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Line::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .chart_proto.Point point1 = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_point1()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_point2;
        break;
      }
      
      // required .chart_proto.Point point2 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_point2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_point2()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Line::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .chart_proto.Point point1 = 1;
  if (has_point1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->point1(), output);
  }
  
  // required .chart_proto.Point point2 = 2;
  if (has_point2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->point2(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Line::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .chart_proto.Point point1 = 1;
  if (has_point1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->point1(), target);
  }
  
  // required .chart_proto.Point point2 = 2;
  if (has_point2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->point2(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Line::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .chart_proto.Point point1 = 1;
    if (has_point1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->point1());
    }
    
    // required .chart_proto.Point point2 = 2;
    if (has_point2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->point2());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Line::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Line* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Line*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Line::MergeFrom(const Line& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_point1()) {
      mutable_point1()->::chart_proto::Point::MergeFrom(from.point1());
    }
    if (from.has_point2()) {
      mutable_point2()->::chart_proto::Point::MergeFrom(from.point2());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Line::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Line::CopyFrom(const Line& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Line::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_point1()) {
    if (!this->point1().IsInitialized()) return false;
  }
  if (has_point2()) {
    if (!this->point2().IsInitialized()) return false;
  }
  return true;
}

void Line::Swap(Line* other) {
  if (other != this) {
    std::swap(point1_, other->point1_);
    std::swap(point2_, other->point2_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Line::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Line_descriptor_;
  metadata.reflection = Line_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Rectangle::kTopLeftFieldNumber;
const int Rectangle::kWidthFieldNumber;
const int Rectangle::kHeightFieldNumber;
#endif  // !_MSC_VER

Rectangle::Rectangle()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Rectangle::InitAsDefaultInstance() {
  top_left_ = const_cast< ::chart_proto::Point*>(&::chart_proto::Point::default_instance());
}

Rectangle::Rectangle(const Rectangle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Rectangle::SharedCtor() {
  _cached_size_ = 0;
  top_left_ = NULL;
  width_ = 0;
  height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Rectangle::~Rectangle() {
  SharedDtor();
}

void Rectangle::SharedDtor() {
  if (this != default_instance_) {
    delete top_left_;
  }
}

void Rectangle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Rectangle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Rectangle_descriptor_;
}

const Rectangle& Rectangle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Rectangle* Rectangle::default_instance_ = NULL;

Rectangle* Rectangle::New() const {
  return new Rectangle;
}

void Rectangle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_top_left()) {
      if (top_left_ != NULL) top_left_->::chart_proto::Point::Clear();
    }
    width_ = 0;
    height_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Rectangle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .chart_proto.Point top_left = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_top_left()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_width;
        break;
      }
      
      // required float width = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_height;
        break;
      }
      
      // required float height = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Rectangle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .chart_proto.Point top_left = 1;
  if (has_top_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->top_left(), output);
  }
  
  // required float width = 2;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->width(), output);
  }
  
  // required float height = 3;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->height(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Rectangle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .chart_proto.Point top_left = 1;
  if (has_top_left()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->top_left(), target);
  }
  
  // required float width = 2;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->width(), target);
  }
  
  // required float height = 3;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->height(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Rectangle::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .chart_proto.Point top_left = 1;
    if (has_top_left()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->top_left());
    }
    
    // required float width = 2;
    if (has_width()) {
      total_size += 1 + 4;
    }
    
    // required float height = 3;
    if (has_height()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Rectangle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Rectangle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Rectangle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Rectangle::MergeFrom(const Rectangle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_top_left()) {
      mutable_top_left()->::chart_proto::Point::MergeFrom(from.top_left());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Rectangle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Rectangle::CopyFrom(const Rectangle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rectangle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_top_left()) {
    if (!this->top_left().IsInitialized()) return false;
  }
  return true;
}

void Rectangle::Swap(Rectangle* other) {
  if (other != this) {
    std::swap(top_left_, other->top_left_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Rectangle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Rectangle_descriptor_;
  metadata.reflection = Rectangle_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Circle::kCenterFieldNumber;
const int Circle::kRadiusFieldNumber;
#endif  // !_MSC_VER

Circle::Circle()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Circle::InitAsDefaultInstance() {
  center_ = const_cast< ::chart_proto::Point*>(&::chart_proto::Point::default_instance());
}

Circle::Circle(const Circle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Circle::SharedCtor() {
  _cached_size_ = 0;
  center_ = NULL;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Circle::~Circle() {
  SharedDtor();
}

void Circle::SharedDtor() {
  if (this != default_instance_) {
    delete center_;
  }
}

void Circle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Circle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Circle_descriptor_;
}

const Circle& Circle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Circle* Circle::default_instance_ = NULL;

Circle* Circle::New() const {
  return new Circle;
}

void Circle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_center()) {
      if (center_ != NULL) center_->::chart_proto::Point::Clear();
    }
    radius_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Circle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .chart_proto.Point center = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_center()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_radius;
        break;
      }
      
      // required float radius = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Circle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .chart_proto.Point center = 1;
  if (has_center()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->center(), output);
  }
  
  // required float radius = 2;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->radius(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Circle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .chart_proto.Point center = 1;
  if (has_center()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->center(), target);
  }
  
  // required float radius = 2;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->radius(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Circle::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .chart_proto.Point center = 1;
    if (has_center()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->center());
    }
    
    // required float radius = 2;
    if (has_radius()) {
      total_size += 1 + 4;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Circle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Circle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Circle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Circle::MergeFrom(const Circle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_center()) {
      mutable_center()->::chart_proto::Point::MergeFrom(from.center());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Circle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Circle::CopyFrom(const Circle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Circle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_center()) {
    if (!this->center().IsInitialized()) return false;
  }
  return true;
}

void Circle::Swap(Circle* other) {
  if (other != this) {
    std::swap(center_, other->center_);
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Circle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Circle_descriptor_;
  metadata.reflection = Circle_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Polygon::kPointFieldNumber;
#endif  // !_MSC_VER

Polygon::Polygon()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Polygon::InitAsDefaultInstance() {
}

Polygon::Polygon(const Polygon& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Polygon::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Polygon::~Polygon() {
  SharedDtor();
}

void Polygon::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Polygon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Polygon::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Polygon_descriptor_;
}

const Polygon& Polygon::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Polygon* Polygon::default_instance_ = NULL;

Polygon* Polygon::New() const {
  return new Polygon;
}

void Polygon::Clear() {
  point_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Polygon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chart_proto.Point point = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_point()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_point;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Polygon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .chart_proto.Point point = 1;
  for (int i = 0; i < this->point_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->point(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Polygon::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .chart_proto.Point point = 1;
  for (int i = 0; i < this->point_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->point(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Polygon::ByteSize() const {
  int total_size = 0;
  
  // repeated .chart_proto.Point point = 1;
  total_size += 1 * this->point_size();
  for (int i = 0; i < this->point_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->point(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Polygon::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Polygon* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Polygon*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Polygon::MergeFrom(const Polygon& from) {
  GOOGLE_CHECK_NE(&from, this);
  point_.MergeFrom(from.point_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Polygon::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Polygon::CopyFrom(const Polygon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polygon::IsInitialized() const {
  
  for (int i = 0; i < point_size(); i++) {
    if (!this->point(i).IsInitialized()) return false;
  }
  return true;
}

void Polygon::Swap(Polygon* other) {
  if (other != this) {
    point_.Swap(&other->point_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Polygon::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Polygon_descriptor_;
  metadata.reflection = Polygon_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Spline::kPointFieldNumber;
#endif  // !_MSC_VER

Spline::Spline()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Spline::InitAsDefaultInstance() {
}

Spline::Spline(const Spline& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Spline::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Spline::~Spline() {
  SharedDtor();
}

void Spline::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Spline::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Spline::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Spline_descriptor_;
}

const Spline& Spline::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Spline* Spline::default_instance_ = NULL;

Spline* Spline::New() const {
  return new Spline;
}

void Spline::Clear() {
  point_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Spline::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chart_proto.Point point = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_point()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_point;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Spline::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .chart_proto.Point point = 1;
  for (int i = 0; i < this->point_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->point(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Spline::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .chart_proto.Point point = 1;
  for (int i = 0; i < this->point_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->point(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Spline::ByteSize() const {
  int total_size = 0;
  
  // repeated .chart_proto.Point point = 1;
  total_size += 1 * this->point_size();
  for (int i = 0; i < this->point_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->point(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Spline::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Spline* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Spline*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Spline::MergeFrom(const Spline& from) {
  GOOGLE_CHECK_NE(&from, this);
  point_.MergeFrom(from.point_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Spline::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Spline::CopyFrom(const Spline& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Spline::IsInitialized() const {
  
  for (int i = 0; i < point_size(); i++) {
    if (!this->point(i).IsInitialized()) return false;
  }
  return true;
}

void Spline::Swap(Spline* other) {
  if (other != this) {
    point_.Swap(&other->point_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Spline::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Spline_descriptor_;
  metadata.reflection = Spline_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Text::kPointFieldNumber;
const int Text::kTextFieldNumber;
#endif  // !_MSC_VER

Text::Text()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Text::InitAsDefaultInstance() {
  point_ = const_cast< ::chart_proto::Point*>(&::chart_proto::Point::default_instance());
}

Text::Text(const Text& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Text::SharedCtor() {
  _cached_size_ = 0;
  point_ = NULL;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Text::~Text() {
  SharedDtor();
}

void Text::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
    delete point_;
  }
}

void Text::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Text::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Text_descriptor_;
}

const Text& Text::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Text* Text::default_instance_ = NULL;

Text* Text::New() const {
  return new Text;
}

void Text::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_point()) {
      if (point_ != NULL) point_->::chart_proto::Point::Clear();
    }
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Text::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .chart_proto.Point point = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_point()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_text;
        break;
      }
      
      // required string text = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Text::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .chart_proto.Point point = 1;
  if (has_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->point(), output);
  }
  
  // required string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->text(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Text::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .chart_proto.Point point = 1;
  if (has_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->point(), target);
  }
  
  // required string text = 2;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->text(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Text::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .chart_proto.Point point = 1;
    if (has_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->point());
    }
    
    // required string text = 2;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Text::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Text* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Text*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Text::MergeFrom(const Text& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_point()) {
      mutable_point()->::chart_proto::Point::MergeFrom(from.point());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Text::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Text::CopyFrom(const Text& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Text::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  
  if (has_point()) {
    if (!this->point().IsInitialized()) return false;
  }
  return true;
}

void Text::Swap(Text* other) {
  if (other != this) {
    std::swap(point_, other->point_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Text::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Text_descriptor_;
  metadata.reflection = Text_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Shape::kLineFieldNumber;
const int Shape::kRectangleFieldNumber;
const int Shape::kCircleFieldNumber;
const int Shape::kPolygonFieldNumber;
const int Shape::kSplineFieldNumber;
const int Shape::kTextFieldNumber;
const int Shape::kStyleFieldNumber;
const int Shape::kTextOffsetFieldNumber;
const int Shape::kTextLengthFieldNumber;
#endif  // !_MSC_VER

Shape::Shape()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Shape::InitAsDefaultInstance() {
  line_ = const_cast< ::chart_proto::Line*>(&::chart_proto::Line::default_instance());
  rectangle_ = const_cast< ::chart_proto::Rectangle*>(&::chart_proto::Rectangle::default_instance());
  circle_ = const_cast< ::chart_proto::Circle*>(&::chart_proto::Circle::default_instance());
  polygon_ = const_cast< ::chart_proto::Polygon*>(&::chart_proto::Polygon::default_instance());
  spline_ = const_cast< ::chart_proto::Spline*>(&::chart_proto::Spline::default_instance());
  text_ = const_cast< ::chart_proto::Text*>(&::chart_proto::Text::default_instance());
  style_ = const_cast< ::chart_proto::Style*>(&::chart_proto::Style::default_instance());
}

Shape::Shape(const Shape& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Shape::SharedCtor() {
  _cached_size_ = 0;
  line_ = NULL;
  rectangle_ = NULL;
  circle_ = NULL;
  polygon_ = NULL;
  spline_ = NULL;
  text_ = NULL;
  style_ = NULL;
  text_offset_ = 0;
  text_length_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Shape::~Shape() {
  SharedDtor();
}

void Shape::SharedDtor() {
  if (this != default_instance_) {
    delete line_;
    delete rectangle_;
    delete circle_;
    delete polygon_;
    delete spline_;
    delete text_;
    delete style_;
  }
}

void Shape::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Shape::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Shape_descriptor_;
}

const Shape& Shape::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Shape* Shape::default_instance_ = NULL;

Shape* Shape::New() const {
  return new Shape;
}

void Shape::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_line()) {
      if (line_ != NULL) line_->::chart_proto::Line::Clear();
    }
    if (has_rectangle()) {
      if (rectangle_ != NULL) rectangle_->::chart_proto::Rectangle::Clear();
    }
    if (has_circle()) {
      if (circle_ != NULL) circle_->::chart_proto::Circle::Clear();
    }
    if (has_polygon()) {
      if (polygon_ != NULL) polygon_->::chart_proto::Polygon::Clear();
    }
    if (has_spline()) {
      if (spline_ != NULL) spline_->::chart_proto::Spline::Clear();
    }
    if (has_text()) {
      if (text_ != NULL) text_->::chart_proto::Text::Clear();
    }
    if (has_style()) {
      if (style_ != NULL) style_->::chart_proto::Style::Clear();
    }
    text_offset_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    text_length_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Shape::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .chart_proto.Line line = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_line()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_rectangle;
        break;
      }
      
      // optional .chart_proto.Rectangle rectangle = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rectangle:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rectangle()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_circle;
        break;
      }
      
      // optional .chart_proto.Circle circle = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_circle:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_circle()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_polygon;
        break;
      }
      
      // optional .chart_proto.Polygon polygon = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_polygon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_polygon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_style;
        break;
      }
      
      // optional .chart_proto.Style style = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_style:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_style()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_text_offset;
        break;
      }
      
      // optional int32 text_offset = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_text_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &text_offset_)));
          set_has_text_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_text_length;
        break;
      }
      
      // optional int32 text_length = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_text_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &text_length_)));
          set_has_text_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_text;
        break;
      }
      
      // optional .chart_proto.Text text = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_spline;
        break;
      }
      
      // optional .chart_proto.Spline spline = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_spline()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Shape::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .chart_proto.Line line = 1;
  if (has_line()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->line(), output);
  }
  
  // optional .chart_proto.Rectangle rectangle = 2;
  if (has_rectangle()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rectangle(), output);
  }
  
  // optional .chart_proto.Circle circle = 3;
  if (has_circle()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->circle(), output);
  }
  
  // optional .chart_proto.Polygon polygon = 4;
  if (has_polygon()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->polygon(), output);
  }
  
  // optional .chart_proto.Style style = 5;
  if (has_style()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->style(), output);
  }
  
  // optional int32 text_offset = 6;
  if (has_text_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->text_offset(), output);
  }
  
  // optional int32 text_length = 7;
  if (has_text_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->text_length(), output);
  }
  
  // optional .chart_proto.Text text = 8;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->text(), output);
  }
  
  // optional .chart_proto.Spline spline = 9;
  if (has_spline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->spline(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Shape::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .chart_proto.Line line = 1;
  if (has_line()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->line(), target);
  }
  
  // optional .chart_proto.Rectangle rectangle = 2;
  if (has_rectangle()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rectangle(), target);
  }
  
  // optional .chart_proto.Circle circle = 3;
  if (has_circle()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->circle(), target);
  }
  
  // optional .chart_proto.Polygon polygon = 4;
  if (has_polygon()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->polygon(), target);
  }
  
  // optional .chart_proto.Style style = 5;
  if (has_style()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->style(), target);
  }
  
  // optional int32 text_offset = 6;
  if (has_text_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->text_offset(), target);
  }
  
  // optional int32 text_length = 7;
  if (has_text_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->text_length(), target);
  }
  
  // optional .chart_proto.Text text = 8;
  if (has_text()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->text(), target);
  }
  
  // optional .chart_proto.Spline spline = 9;
  if (has_spline()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->spline(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Shape::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .chart_proto.Line line = 1;
    if (has_line()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->line());
    }
    
    // optional .chart_proto.Rectangle rectangle = 2;
    if (has_rectangle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rectangle());
    }
    
    // optional .chart_proto.Circle circle = 3;
    if (has_circle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->circle());
    }
    
    // optional .chart_proto.Polygon polygon = 4;
    if (has_polygon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->polygon());
    }
    
    // optional .chart_proto.Spline spline = 9;
    if (has_spline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->spline());
    }
    
    // optional .chart_proto.Text text = 8;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->text());
    }
    
    // optional .chart_proto.Style style = 5;
    if (has_style()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->style());
    }
    
    // optional int32 text_offset = 6;
    if (has_text_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->text_offset());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 text_length = 7;
    if (has_text_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->text_length());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Shape::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Shape* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Shape*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Shape::MergeFrom(const Shape& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_line()) {
      mutable_line()->::chart_proto::Line::MergeFrom(from.line());
    }
    if (from.has_rectangle()) {
      mutable_rectangle()->::chart_proto::Rectangle::MergeFrom(from.rectangle());
    }
    if (from.has_circle()) {
      mutable_circle()->::chart_proto::Circle::MergeFrom(from.circle());
    }
    if (from.has_polygon()) {
      mutable_polygon()->::chart_proto::Polygon::MergeFrom(from.polygon());
    }
    if (from.has_spline()) {
      mutable_spline()->::chart_proto::Spline::MergeFrom(from.spline());
    }
    if (from.has_text()) {
      mutable_text()->::chart_proto::Text::MergeFrom(from.text());
    }
    if (from.has_style()) {
      mutable_style()->::chart_proto::Style::MergeFrom(from.style());
    }
    if (from.has_text_offset()) {
      set_text_offset(from.text_offset());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_text_length()) {
      set_text_length(from.text_length());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Shape::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Shape::CopyFrom(const Shape& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Shape::IsInitialized() const {
  
  if (has_line()) {
    if (!this->line().IsInitialized()) return false;
  }
  if (has_rectangle()) {
    if (!this->rectangle().IsInitialized()) return false;
  }
  if (has_circle()) {
    if (!this->circle().IsInitialized()) return false;
  }
  if (has_polygon()) {
    if (!this->polygon().IsInitialized()) return false;
  }
  if (has_spline()) {
    if (!this->spline().IsInitialized()) return false;
  }
  if (has_text()) {
    if (!this->text().IsInitialized()) return false;
  }
  if (has_style()) {
    if (!this->style().IsInitialized()) return false;
  }
  return true;
}

void Shape::Swap(Shape* other) {
  if (other != this) {
    std::swap(line_, other->line_);
    std::swap(rectangle_, other->rectangle_);
    std::swap(circle_, other->circle_);
    std::swap(polygon_, other->polygon_);
    std::swap(spline_, other->spline_);
    std::swap(text_, other->text_);
    std::swap(style_, other->style_);
    std::swap(text_offset_, other->text_offset_);
    std::swap(text_length_, other->text_length_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Shape::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Shape_descriptor_;
  metadata.reflection = Shape_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Graphic::kShapeFieldNumber;
const int Graphic::kWidthFieldNumber;
const int Graphic::kHeightFieldNumber;
#endif  // !_MSC_VER

Graphic::Graphic()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Graphic::InitAsDefaultInstance() {
}

Graphic::Graphic(const Graphic& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Graphic::SharedCtor() {
  _cached_size_ = 0;
  width_ = 0;
  height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Graphic::~Graphic() {
  SharedDtor();
}

void Graphic::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Graphic::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Graphic::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Graphic_descriptor_;
}

const Graphic& Graphic::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Graphic* Graphic::default_instance_ = NULL;

Graphic* Graphic::New() const {
  return new Graphic;
}

void Graphic::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    width_ = 0;
    height_ = 0;
  }
  shape_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Graphic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chart_proto.Shape shape = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shape:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shape()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_shape;
        if (input->ExpectTag(21)) goto parse_width;
        break;
      }
      
      // optional float width = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_height;
        break;
      }
      
      // optional float height = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Graphic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .chart_proto.Shape shape = 1;
  for (int i = 0; i < this->shape_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->shape(i), output);
  }
  
  // optional float width = 2;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->width(), output);
  }
  
  // optional float height = 3;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->height(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Graphic::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .chart_proto.Shape shape = 1;
  for (int i = 0; i < this->shape_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->shape(i), target);
  }
  
  // optional float width = 2;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->width(), target);
  }
  
  // optional float height = 3;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->height(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Graphic::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional float width = 2;
    if (has_width()) {
      total_size += 1 + 4;
    }
    
    // optional float height = 3;
    if (has_height()) {
      total_size += 1 + 4;
    }
    
  }
  // repeated .chart_proto.Shape shape = 1;
  total_size += 1 * this->shape_size();
  for (int i = 0; i < this->shape_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shape(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Graphic::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Graphic* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Graphic*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Graphic::MergeFrom(const Graphic& from) {
  GOOGLE_CHECK_NE(&from, this);
  shape_.MergeFrom(from.shape_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Graphic::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Graphic::CopyFrom(const Graphic& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Graphic::IsInitialized() const {
  
  for (int i = 0; i < shape_size(); i++) {
    if (!this->shape(i).IsInitialized()) return false;
  }
  return true;
}

void Graphic::Swap(Graphic* other) {
  if (other != this) {
    shape_.Swap(&other->shape_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Graphic::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Graphic_descriptor_;
  metadata.reflection = Graphic_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Action::kActionFieldNumber;
const int Action::kWidthFieldNumber;
const int Action::kRepetitionsFieldNumber;
const int Action::kTextOffsetFieldNumber;
const int Action::kTextLengthFieldNumber;
#endif  // !_MSC_VER

Action::Action()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Action::InitAsDefaultInstance() {
}

Action::Action(const Action& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Action::SharedCtor() {
  _cached_size_ = 0;
  action_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  width_ = 0;
  repetitions_ = 1;
  text_offset_ = 0;
  text_length_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Action::~Action() {
  SharedDtor();
}

void Action::SharedDtor() {
  if (action_ != &::google::protobuf::internal::kEmptyString) {
    delete action_;
  }
  if (this != default_instance_) {
  }
}

void Action::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Action::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Action_descriptor_;
}

const Action& Action::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Action* Action::default_instance_ = NULL;

Action* Action::New() const {
  return new Action;
}

void Action::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_action()) {
      if (action_ != &::google::protobuf::internal::kEmptyString) {
        action_->clear();
      }
    }
    width_ = 0;
    repetitions_ = 1;
    text_offset_ = 0;
    text_length_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Action::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string action = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_action()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->action().data(), this->action().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_repetitions;
        break;
      }
      
      // optional int32 repetitions = 2 [default = 1];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_repetitions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &repetitions_)));
          set_has_repetitions();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_width;
        break;
      }
      
      // required int32 width = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_text_offset;
        break;
      }
      
      // optional int32 text_offset = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_text_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &text_offset_)));
          set_has_text_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_text_length;
        break;
      }
      
      // optional int32 text_length = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_text_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &text_length_)));
          set_has_text_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Action::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string action = 1;
  if (has_action()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->action().data(), this->action().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->action(), output);
  }
  
  // optional int32 repetitions = 2 [default = 1];
  if (has_repetitions()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->repetitions(), output);
  }
  
  // required int32 width = 3;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->width(), output);
  }
  
  // optional int32 text_offset = 4;
  if (has_text_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->text_offset(), output);
  }
  
  // optional int32 text_length = 5;
  if (has_text_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->text_length(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Action::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string action = 1;
  if (has_action()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->action().data(), this->action().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->action(), target);
  }
  
  // optional int32 repetitions = 2 [default = 1];
  if (has_repetitions()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->repetitions(), target);
  }
  
  // required int32 width = 3;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->width(), target);
  }
  
  // optional int32 text_offset = 4;
  if (has_text_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->text_offset(), target);
  }
  
  // optional int32 text_length = 5;
  if (has_text_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->text_length(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Action::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string action = 1;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->action());
    }
    
    // required int32 width = 3;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
    // optional int32 repetitions = 2 [default = 1];
    if (has_repetitions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->repetitions());
    }
    
    // optional int32 text_offset = 4;
    if (has_text_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->text_offset());
    }
    
    // optional int32 text_length = 5;
    if (has_text_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->text_length());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Action::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Action* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Action*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Action::MergeFrom(const Action& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_action()) {
      set_action(from.action());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_repetitions()) {
      set_repetitions(from.repetitions());
    }
    if (from.has_text_offset()) {
      set_text_offset(from.text_offset());
    }
    if (from.has_text_length()) {
      set_text_length(from.text_length());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Action::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Action::CopyFrom(const Action& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Action::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Action::Swap(Action* other) {
  if (other != this) {
    std::swap(action_, other->action_);
    std::swap(width_, other->width_);
    std::swap(repetitions_, other->repetitions_);
    std::swap(text_offset_, other->text_offset_);
    std::swap(text_length_, other->text_length_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Action::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Action_descriptor_;
  metadata.reflection = Action_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Row::kActionFieldNumber;
#endif  // !_MSC_VER

Row::Row()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Row::InitAsDefaultInstance() {
}

Row::Row(const Row& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Row::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Row::~Row() {
  SharedDtor();
}

void Row::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Row::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Row::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Row_descriptor_;
}

const Row& Row::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Row* Row::default_instance_ = NULL;

Row* Row::New() const {
  return new Row;
}

void Row::Clear() {
  action_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Row::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chart_proto.Action action = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_action:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_action()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_action;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Row::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .chart_proto.Action action = 1;
  for (int i = 0; i < this->action_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->action(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Row::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .chart_proto.Action action = 1;
  for (int i = 0; i < this->action_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->action(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Row::ByteSize() const {
  int total_size = 0;
  
  // repeated .chart_proto.Action action = 1;
  total_size += 1 * this->action_size();
  for (int i = 0; i < this->action_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->action(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Row::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Row* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Row*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Row::MergeFrom(const Row& from) {
  GOOGLE_CHECK_NE(&from, this);
  action_.MergeFrom(from.action_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Row::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Row::CopyFrom(const Row& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Row::IsInitialized() const {
  
  for (int i = 0; i < action_size(); i++) {
    if (!this->action(i).IsInitialized()) return false;
  }
  return true;
}

void Row::Swap(Row* other) {
  if (other != this) {
    action_.Swap(&other->action_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Row::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Row_descriptor_;
  metadata.reflection = Row_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ActionType::kNameFieldNumber;
const int ActionType::kWidthFieldNumber;
const int ActionType::kGraphicFieldNumber;
#endif  // !_MSC_VER

ActionType::ActionType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ActionType::InitAsDefaultInstance() {
  graphic_ = const_cast< ::chart_proto::Graphic*>(&::chart_proto::Graphic::default_instance());
}

ActionType::ActionType(const ActionType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ActionType::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  width_ = 1;
  graphic_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActionType::~ActionType() {
  SharedDtor();
}

void ActionType::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete graphic_;
  }
}

void ActionType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ActionType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ActionType_descriptor_;
}

const ActionType& ActionType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

ActionType* ActionType::default_instance_ = NULL;

ActionType* ActionType::New() const {
  return new ActionType;
}

void ActionType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    width_ = 1;
    if (has_graphic()) {
      if (graphic_ != NULL) graphic_->::chart_proto::Graphic::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ActionType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_width;
        break;
      }
      
      // optional int32 width = 2 [default = 1];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_graphic;
        break;
      }
      
      // optional .chart_proto.Graphic graphic = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_graphic:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_graphic()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ActionType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional int32 width = 2 [default = 1];
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->width(), output);
  }
  
  // optional .chart_proto.Graphic graphic = 4;
  if (has_graphic()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->graphic(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ActionType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional int32 width = 2 [default = 1];
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->width(), target);
  }
  
  // optional .chart_proto.Graphic graphic = 4;
  if (has_graphic()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->graphic(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ActionType::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional int32 width = 2 [default = 1];
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
    // optional .chart_proto.Graphic graphic = 4;
    if (has_graphic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->graphic());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActionType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ActionType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ActionType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ActionType::MergeFrom(const ActionType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_graphic()) {
      mutable_graphic()->::chart_proto::Graphic::MergeFrom(from.graphic());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ActionType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ActionType::CopyFrom(const ActionType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_graphic()) {
    if (!this->graphic().IsInitialized()) return false;
  }
  return true;
}

void ActionType::Swap(ActionType* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(width_, other->width_);
    std::swap(graphic_, other->graphic_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ActionType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ActionType_descriptor_;
  metadata.reflection = ActionType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Library::kActionTypeFieldNumber;
#endif  // !_MSC_VER

Library::Library()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Library::InitAsDefaultInstance() {
}

Library::Library(const Library& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Library::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Library::~Library() {
  SharedDtor();
}

void Library::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Library::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Library::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Library_descriptor_;
}

const Library& Library::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Library* Library::default_instance_ = NULL;

Library* Library::New() const {
  return new Library;
}

void Library::Clear() {
  action_type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Library::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chart_proto.ActionType action_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_action_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_action_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_action_type;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Library::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .chart_proto.ActionType action_type = 1;
  for (int i = 0; i < this->action_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->action_type(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Library::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .chart_proto.ActionType action_type = 1;
  for (int i = 0; i < this->action_type_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->action_type(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Library::ByteSize() const {
  int total_size = 0;
  
  // repeated .chart_proto.ActionType action_type = 1;
  total_size += 1 * this->action_type_size();
  for (int i = 0; i < this->action_type_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->action_type(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Library::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Library* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Library*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Library::MergeFrom(const Library& from) {
  GOOGLE_CHECK_NE(&from, this);
  action_type_.MergeFrom(from.action_type_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Library::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Library::CopyFrom(const Library& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Library::IsInitialized() const {
  
  for (int i = 0; i < action_type_size(); i++) {
    if (!this->action_type(i).IsInitialized()) return false;
  }
  return true;
}

void Library::Swap(Library* other) {
  if (other != this) {
    action_type_.Swap(&other->action_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Library::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Library_descriptor_;
  metadata.reflection = Library_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Chart::kRowFieldNumber;
const int Chart::kLibraryFieldNumber;
#endif  // !_MSC_VER

Chart::Chart()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Chart::InitAsDefaultInstance() {
  library_ = const_cast< ::chart_proto::Library*>(&::chart_proto::Library::default_instance());
}

Chart::Chart(const Chart& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Chart::SharedCtor() {
  _cached_size_ = 0;
  library_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Chart::~Chart() {
  SharedDtor();
}

void Chart::SharedDtor() {
  if (this != default_instance_) {
    delete library_;
  }
}

void Chart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Chart::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Chart_descriptor_;
}

const Chart& Chart::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

Chart* Chart::default_instance_ = NULL;

Chart* Chart::New() const {
  return new Chart;
}

void Chart::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_library()) {
      if (library_ != NULL) library_->::chart_proto::Library::Clear();
    }
  }
  row_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Chart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chart_proto.Row row = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_row:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_row()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_row;
        if (input->ExpectTag(18)) goto parse_library;
        break;
      }
      
      // optional .chart_proto.Library library = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_library:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_library()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Chart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .chart_proto.Row row = 1;
  for (int i = 0; i < this->row_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->row(i), output);
  }
  
  // optional .chart_proto.Library library = 2;
  if (has_library()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->library(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Chart::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .chart_proto.Row row = 1;
  for (int i = 0; i < this->row_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->row(i), target);
  }
  
  // optional .chart_proto.Library library = 2;
  if (has_library()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->library(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Chart::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .chart_proto.Library library = 2;
    if (has_library()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->library());
    }
    
  }
  // repeated .chart_proto.Row row = 1;
  total_size += 1 * this->row_size();
  for (int i = 0; i < this->row_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->row(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Chart::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Chart* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Chart*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Chart::MergeFrom(const Chart& from) {
  GOOGLE_CHECK_NE(&from, this);
  row_.MergeFrom(from.row_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_library()) {
      mutable_library()->::chart_proto::Library::MergeFrom(from.library());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Chart::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Chart::CopyFrom(const Chart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chart::IsInitialized() const {
  
  for (int i = 0; i < row_size(); i++) {
    if (!this->row(i).IsInitialized()) return false;
  }
  if (has_library()) {
    if (!this->library().IsInitialized()) return false;
  }
  return true;
}

void Chart::Swap(Chart* other) {
  if (other != this) {
    row_.Swap(&other->row_);
    std::swap(library_, other->library_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Chart::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Chart_descriptor_;
  metadata.reflection = Chart_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChartFile::kLibraryFieldNumber;
const int ChartFile::kTextFieldNumber;
#endif  // !_MSC_VER

ChartFile::ChartFile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChartFile::InitAsDefaultInstance() {
  library_ = const_cast< ::chart_proto::Library*>(&::chart_proto::Library::default_instance());
}

ChartFile::ChartFile(const ChartFile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChartFile::SharedCtor() {
  _cached_size_ = 0;
  library_ = NULL;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChartFile::~ChartFile() {
  SharedDtor();
}

void ChartFile::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
    delete library_;
  }
}

void ChartFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChartFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChartFile_descriptor_;
}

const ChartFile& ChartFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_storage_2fchart_2eproto();  return *default_instance_;
}

ChartFile* ChartFile::default_instance_ = NULL;

ChartFile* ChartFile::New() const {
  return new ChartFile;
}

void ChartFile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_library()) {
      if (library_ != NULL) library_->::chart_proto::Library::Clear();
    }
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChartFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .chart_proto.Library library = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_library()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_text;
        break;
      }
      
      // optional string text = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChartFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .chart_proto.Library library = 2;
  if (has_library()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->library(), output);
  }
  
  // optional string text = 4;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->text(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChartFile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .chart_proto.Library library = 2;
  if (has_library()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->library(), target);
  }
  
  // optional string text = 4;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->text(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChartFile::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .chart_proto.Library library = 2;
    if (has_library()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->library());
    }
    
    // optional string text = 4;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChartFile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChartFile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChartFile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChartFile::MergeFrom(const ChartFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_library()) {
      mutable_library()->::chart_proto::Library::MergeFrom(from.library());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChartFile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChartFile::CopyFrom(const ChartFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChartFile::IsInitialized() const {
  
  if (has_library()) {
    if (!this->library().IsInitialized()) return false;
  }
  return true;
}

void ChartFile::Swap(ChartFile* other) {
  if (other != this) {
    std::swap(library_, other->library_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChartFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChartFile_descriptor_;
  metadata.reflection = ChartFile_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace chart_proto

// @@protoc_insertion_point(global_scope)
