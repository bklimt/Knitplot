// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_storage_2fchart_2eproto__INCLUDED
#define PROTOBUF_storage_2fchart_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>

namespace chart_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_storage_2fchart_2eproto();
void protobuf_AssignDesc_storage_2fchart_2eproto();
void protobuf_ShutdownFile_storage_2fchart_2eproto();

class Color;
class Style;
class Point;
class Line;
class Rectangle;
class Circle;
class Polygon;
class Spline;
class Text;
class Shape;
class Graphic;
class Action;
class Row;
class ActionType;
class Library;
class Chart;
class ChartFile;

// ===================================================================

class Color : public ::google::protobuf::Message {
 public:
  Color();
  virtual ~Color();
  
  Color(const Color& from);
  
  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Color& default_instance();
  void Swap(Color* other);
  
  // implements Message ----------------------------------------------
  
  Color* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 red = 1;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 1;
  inline ::google::protobuf::int32 red() const;
  inline void set_red(::google::protobuf::int32 value);
  
  // required int32 green = 2;
  inline bool has_green() const;
  inline void clear_green();
  static const int kGreenFieldNumber = 2;
  inline ::google::protobuf::int32 green() const;
  inline void set_green(::google::protobuf::int32 value);
  
  // required int32 blue = 3;
  inline bool has_blue() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 3;
  inline ::google::protobuf::int32 blue() const;
  inline void set_blue(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 red_;
  ::google::protobuf::int32 green_;
  ::google::protobuf::int32 blue_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Color* default_instance_;
};
// -------------------------------------------------------------------

class Style : public ::google::protobuf::Message {
 public:
  Style();
  virtual ~Style();
  
  Style(const Style& from);
  
  inline Style& operator=(const Style& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Style& default_instance();
  void Swap(Style* other);
  
  // implements Message ----------------------------------------------
  
  Style* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Style& from);
  void MergeFrom(const Style& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .chart_proto.Color fill = 1;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 1;
  inline const ::chart_proto::Color& fill() const;
  inline ::chart_proto::Color* mutable_fill();
  
  // optional .chart_proto.Color stroke = 2;
  inline bool has_stroke() const;
  inline void clear_stroke();
  static const int kStrokeFieldNumber = 2;
  inline const ::chart_proto::Color& stroke() const;
  inline ::chart_proto::Color* mutable_stroke();
  
  // optional int32 stroke_width = 3 [default = 1];
  inline bool has_stroke_width() const;
  inline void clear_stroke_width();
  static const int kStrokeWidthFieldNumber = 3;
  inline ::google::protobuf::int32 stroke_width() const;
  inline void set_stroke_width(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::chart_proto::Color* fill_;
  ::chart_proto::Color* stroke_;
  ::google::protobuf::int32 stroke_width_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Style* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();
  
  Point(const Point& from);
  
  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();
  void Swap(Point* other);
  
  // implements Message ----------------------------------------------
  
  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float x_;
  float y_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Line : public ::google::protobuf::Message {
 public:
  Line();
  virtual ~Line();
  
  Line(const Line& from);
  
  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Line& default_instance();
  void Swap(Line* other);
  
  // implements Message ----------------------------------------------
  
  Line* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .chart_proto.Point point1 = 1;
  inline bool has_point1() const;
  inline void clear_point1();
  static const int kPoint1FieldNumber = 1;
  inline const ::chart_proto::Point& point1() const;
  inline ::chart_proto::Point* mutable_point1();
  
  // required .chart_proto.Point point2 = 2;
  inline bool has_point2() const;
  inline void clear_point2();
  static const int kPoint2FieldNumber = 2;
  inline const ::chart_proto::Point& point2() const;
  inline ::chart_proto::Point* mutable_point2();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::chart_proto::Point* point1_;
  ::chart_proto::Point* point2_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Line* default_instance_;
};
// -------------------------------------------------------------------

class Rectangle : public ::google::protobuf::Message {
 public:
  Rectangle();
  virtual ~Rectangle();
  
  Rectangle(const Rectangle& from);
  
  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rectangle& default_instance();
  void Swap(Rectangle* other);
  
  // implements Message ----------------------------------------------
  
  Rectangle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rectangle& from);
  void MergeFrom(const Rectangle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .chart_proto.Point top_left = 1;
  inline bool has_top_left() const;
  inline void clear_top_left();
  static const int kTopLeftFieldNumber = 1;
  inline const ::chart_proto::Point& top_left() const;
  inline ::chart_proto::Point* mutable_top_left();
  
  // required float width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline float width() const;
  inline void set_width(float value);
  
  // required float height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline float height() const;
  inline void set_height(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::chart_proto::Point* top_left_;
  float width_;
  float height_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Rectangle* default_instance_;
};
// -------------------------------------------------------------------

class Circle : public ::google::protobuf::Message {
 public:
  Circle();
  virtual ~Circle();
  
  Circle(const Circle& from);
  
  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Circle& default_instance();
  void Swap(Circle* other);
  
  // implements Message ----------------------------------------------
  
  Circle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Circle& from);
  void MergeFrom(const Circle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .chart_proto.Point center = 1;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 1;
  inline const ::chart_proto::Point& center() const;
  inline ::chart_proto::Point* mutable_center();
  
  // required float radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline float radius() const;
  inline void set_radius(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::chart_proto::Point* center_;
  float radius_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Circle* default_instance_;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message {
 public:
  Polygon();
  virtual ~Polygon();
  
  Polygon(const Polygon& from);
  
  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();
  void Swap(Polygon* other);
  
  // implements Message ----------------------------------------------
  
  Polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .chart_proto.Point point = 1;
  inline int point_size() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Point >& point() const;
  inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Point >* mutable_point();
  inline const ::chart_proto::Point& point(int index) const;
  inline ::chart_proto::Point* mutable_point(int index);
  inline ::chart_proto::Point* add_point();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::chart_proto::Point > point_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Polygon* default_instance_;
};
// -------------------------------------------------------------------

class Spline : public ::google::protobuf::Message {
 public:
  Spline();
  virtual ~Spline();
  
  Spline(const Spline& from);
  
  inline Spline& operator=(const Spline& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Spline& default_instance();
  void Swap(Spline* other);
  
  // implements Message ----------------------------------------------
  
  Spline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Spline& from);
  void MergeFrom(const Spline& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .chart_proto.Point point = 1;
  inline int point_size() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Point >& point() const;
  inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Point >* mutable_point();
  inline const ::chart_proto::Point& point(int index) const;
  inline ::chart_proto::Point* mutable_point(int index);
  inline ::chart_proto::Point* add_point();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::chart_proto::Point > point_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Spline* default_instance_;
};
// -------------------------------------------------------------------

class Text : public ::google::protobuf::Message {
 public:
  Text();
  virtual ~Text();
  
  Text(const Text& from);
  
  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Text& default_instance();
  void Swap(Text* other);
  
  // implements Message ----------------------------------------------
  
  Text* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Text& from);
  void MergeFrom(const Text& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .chart_proto.Point point = 1;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::chart_proto::Point& point() const;
  inline ::chart_proto::Point* mutable_point();
  
  // required string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::chart_proto::Point* point_;
  ::std::string* text_;
  static const ::std::string _default_text_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Text* default_instance_;
};
// -------------------------------------------------------------------

class Shape : public ::google::protobuf::Message {
 public:
  Shape();
  virtual ~Shape();
  
  Shape(const Shape& from);
  
  inline Shape& operator=(const Shape& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Shape& default_instance();
  void Swap(Shape* other);
  
  // implements Message ----------------------------------------------
  
  Shape* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Shape& from);
  void MergeFrom(const Shape& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .chart_proto.Line line = 1;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 1;
  inline const ::chart_proto::Line& line() const;
  inline ::chart_proto::Line* mutable_line();
  
  // optional .chart_proto.Rectangle rectangle = 2;
  inline bool has_rectangle() const;
  inline void clear_rectangle();
  static const int kRectangleFieldNumber = 2;
  inline const ::chart_proto::Rectangle& rectangle() const;
  inline ::chart_proto::Rectangle* mutable_rectangle();
  
  // optional .chart_proto.Circle circle = 3;
  inline bool has_circle() const;
  inline void clear_circle();
  static const int kCircleFieldNumber = 3;
  inline const ::chart_proto::Circle& circle() const;
  inline ::chart_proto::Circle* mutable_circle();
  
  // optional .chart_proto.Polygon polygon = 4;
  inline bool has_polygon() const;
  inline void clear_polygon();
  static const int kPolygonFieldNumber = 4;
  inline const ::chart_proto::Polygon& polygon() const;
  inline ::chart_proto::Polygon* mutable_polygon();
  
  // optional .chart_proto.Spline spline = 9;
  inline bool has_spline() const;
  inline void clear_spline();
  static const int kSplineFieldNumber = 9;
  inline const ::chart_proto::Spline& spline() const;
  inline ::chart_proto::Spline* mutable_spline();
  
  // optional .chart_proto.Text text = 8;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 8;
  inline const ::chart_proto::Text& text() const;
  inline ::chart_proto::Text* mutable_text();
  
  // optional .chart_proto.Style style = 5;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 5;
  inline const ::chart_proto::Style& style() const;
  inline ::chart_proto::Style* mutable_style();
  
  // optional int32 text_offset = 6;
  inline bool has_text_offset() const;
  inline void clear_text_offset();
  static const int kTextOffsetFieldNumber = 6;
  inline ::google::protobuf::int32 text_offset() const;
  inline void set_text_offset(::google::protobuf::int32 value);
  
  // optional int32 text_length = 7;
  inline bool has_text_length() const;
  inline void clear_text_length();
  static const int kTextLengthFieldNumber = 7;
  inline ::google::protobuf::int32 text_length() const;
  inline void set_text_length(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::chart_proto::Line* line_;
  ::chart_proto::Rectangle* rectangle_;
  ::chart_proto::Circle* circle_;
  ::chart_proto::Polygon* polygon_;
  ::chart_proto::Spline* spline_;
  ::chart_proto::Text* text_;
  ::chart_proto::Style* style_;
  ::google::protobuf::int32 text_offset_;
  ::google::protobuf::int32 text_length_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Shape* default_instance_;
};
// -------------------------------------------------------------------

class Graphic : public ::google::protobuf::Message {
 public:
  Graphic();
  virtual ~Graphic();
  
  Graphic(const Graphic& from);
  
  inline Graphic& operator=(const Graphic& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Graphic& default_instance();
  void Swap(Graphic* other);
  
  // implements Message ----------------------------------------------
  
  Graphic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Graphic& from);
  void MergeFrom(const Graphic& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .chart_proto.Shape shape = 1;
  inline int shape_size() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Shape >& shape() const;
  inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Shape >* mutable_shape();
  inline const ::chart_proto::Shape& shape(int index) const;
  inline ::chart_proto::Shape* mutable_shape(int index);
  inline ::chart_proto::Shape* add_shape();
  
  // optional float width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline float width() const;
  inline void set_width(float value);
  
  // optional float height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline float height() const;
  inline void set_height(float value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::chart_proto::Shape > shape_;
  float width_;
  float height_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Graphic* default_instance_;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message {
 public:
  Action();
  virtual ~Action();
  
  Action(const Action& from);
  
  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();
  void Swap(Action* other);
  
  // implements Message ----------------------------------------------
  
  Action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  
  // required int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 repetitions = 2 [default = 1];
  inline bool has_repetitions() const;
  inline void clear_repetitions();
  static const int kRepetitionsFieldNumber = 2;
  inline ::google::protobuf::int32 repetitions() const;
  inline void set_repetitions(::google::protobuf::int32 value);
  
  // optional int32 text_offset = 4;
  inline bool has_text_offset() const;
  inline void clear_text_offset();
  static const int kTextOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 text_offset() const;
  inline void set_text_offset(::google::protobuf::int32 value);
  
  // optional int32 text_length = 5;
  inline bool has_text_length() const;
  inline void clear_text_length();
  static const int kTextLengthFieldNumber = 5;
  inline ::google::protobuf::int32 text_length() const;
  inline void set_text_length(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* action_;
  static const ::std::string _default_action_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 repetitions_;
  ::google::protobuf::int32 text_offset_;
  ::google::protobuf::int32 text_length_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Action* default_instance_;
};
// -------------------------------------------------------------------

class Row : public ::google::protobuf::Message {
 public:
  Row();
  virtual ~Row();
  
  Row(const Row& from);
  
  inline Row& operator=(const Row& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Row& default_instance();
  void Swap(Row* other);
  
  // implements Message ----------------------------------------------
  
  Row* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Row& from);
  void MergeFrom(const Row& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .chart_proto.Action action = 1;
  inline int action_size() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Action >& action() const;
  inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Action >* mutable_action();
  inline const ::chart_proto::Action& action(int index) const;
  inline ::chart_proto::Action* mutable_action(int index);
  inline ::chart_proto::Action* add_action();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::chart_proto::Action > action_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Row* default_instance_;
};
// -------------------------------------------------------------------

class ActionType : public ::google::protobuf::Message {
 public:
  ActionType();
  virtual ~ActionType();
  
  ActionType(const ActionType& from);
  
  inline ActionType& operator=(const ActionType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionType& default_instance();
  void Swap(ActionType* other);
  
  // implements Message ----------------------------------------------
  
  ActionType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionType& from);
  void MergeFrom(const ActionType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional int32 width = 2 [default = 1];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional .chart_proto.Graphic graphic = 4;
  inline bool has_graphic() const;
  inline void clear_graphic();
  static const int kGraphicFieldNumber = 4;
  inline const ::chart_proto::Graphic& graphic() const;
  inline ::chart_proto::Graphic* mutable_graphic();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 width_;
  ::chart_proto::Graphic* graphic_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ActionType* default_instance_;
};
// -------------------------------------------------------------------

class Library : public ::google::protobuf::Message {
 public:
  Library();
  virtual ~Library();
  
  Library(const Library& from);
  
  inline Library& operator=(const Library& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Library& default_instance();
  void Swap(Library* other);
  
  // implements Message ----------------------------------------------
  
  Library* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Library& from);
  void MergeFrom(const Library& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .chart_proto.ActionType action_type = 1;
  inline int action_type_size() const;
  inline void clear_action_type();
  static const int kActionTypeFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::ActionType >& action_type() const;
  inline ::google::protobuf::RepeatedPtrField< ::chart_proto::ActionType >* mutable_action_type();
  inline const ::chart_proto::ActionType& action_type(int index) const;
  inline ::chart_proto::ActionType* mutable_action_type(int index);
  inline ::chart_proto::ActionType* add_action_type();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::chart_proto::ActionType > action_type_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Library* default_instance_;
};
// -------------------------------------------------------------------

class Chart : public ::google::protobuf::Message {
 public:
  Chart();
  virtual ~Chart();
  
  Chart(const Chart& from);
  
  inline Chart& operator=(const Chart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chart& default_instance();
  void Swap(Chart* other);
  
  // implements Message ----------------------------------------------
  
  Chart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Chart& from);
  void MergeFrom(const Chart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .chart_proto.Row row = 1;
  inline int row_size() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Row >& row() const;
  inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Row >* mutable_row();
  inline const ::chart_proto::Row& row(int index) const;
  inline ::chart_proto::Row* mutable_row(int index);
  inline ::chart_proto::Row* add_row();
  
  // optional .chart_proto.Library library = 2;
  inline bool has_library() const;
  inline void clear_library();
  static const int kLibraryFieldNumber = 2;
  inline const ::chart_proto::Library& library() const;
  inline ::chart_proto::Library* mutable_library();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::chart_proto::Row > row_;
  ::chart_proto::Library* library_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Chart* default_instance_;
};
// -------------------------------------------------------------------

class ChartFile : public ::google::protobuf::Message {
 public:
  ChartFile();
  virtual ~ChartFile();
  
  ChartFile(const ChartFile& from);
  
  inline ChartFile& operator=(const ChartFile& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartFile& default_instance();
  void Swap(ChartFile* other);
  
  // implements Message ----------------------------------------------
  
  ChartFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartFile& from);
  void MergeFrom(const ChartFile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .chart_proto.Library library = 2;
  inline bool has_library() const;
  inline void clear_library();
  static const int kLibraryFieldNumber = 2;
  inline const ::chart_proto::Library& library() const;
  inline ::chart_proto::Library* mutable_library();
  
  // optional string text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::chart_proto::Library* library_;
  ::std::string* text_;
  static const ::std::string _default_text_;
  friend void  protobuf_AddDesc_storage_2fchart_2eproto();
  friend void protobuf_AssignDesc_storage_2fchart_2eproto();
  friend void protobuf_ShutdownFile_storage_2fchart_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ChartFile* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// Color

// required int32 red = 1;
inline bool Color::has_red() const {
  return _has_bit(0);
}
inline void Color::clear_red() {
  red_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Color::red() const {
  return red_;
}
inline void Color::set_red(::google::protobuf::int32 value) {
  _set_bit(0);
  red_ = value;
}

// required int32 green = 2;
inline bool Color::has_green() const {
  return _has_bit(1);
}
inline void Color::clear_green() {
  green_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Color::green() const {
  return green_;
}
inline void Color::set_green(::google::protobuf::int32 value) {
  _set_bit(1);
  green_ = value;
}

// required int32 blue = 3;
inline bool Color::has_blue() const {
  return _has_bit(2);
}
inline void Color::clear_blue() {
  blue_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Color::blue() const {
  return blue_;
}
inline void Color::set_blue(::google::protobuf::int32 value) {
  _set_bit(2);
  blue_ = value;
}

// -------------------------------------------------------------------

// Style

// optional .chart_proto.Color fill = 1;
inline bool Style::has_fill() const {
  return _has_bit(0);
}
inline void Style::clear_fill() {
  if (fill_ != NULL) fill_->::chart_proto::Color::Clear();
  _clear_bit(0);
}
inline const ::chart_proto::Color& Style::fill() const {
  return fill_ != NULL ? *fill_ : *default_instance_->fill_;
}
inline ::chart_proto::Color* Style::mutable_fill() {
  _set_bit(0);
  if (fill_ == NULL) fill_ = new ::chart_proto::Color;
  return fill_;
}

// optional .chart_proto.Color stroke = 2;
inline bool Style::has_stroke() const {
  return _has_bit(1);
}
inline void Style::clear_stroke() {
  if (stroke_ != NULL) stroke_->::chart_proto::Color::Clear();
  _clear_bit(1);
}
inline const ::chart_proto::Color& Style::stroke() const {
  return stroke_ != NULL ? *stroke_ : *default_instance_->stroke_;
}
inline ::chart_proto::Color* Style::mutable_stroke() {
  _set_bit(1);
  if (stroke_ == NULL) stroke_ = new ::chart_proto::Color;
  return stroke_;
}

// optional int32 stroke_width = 3 [default = 1];
inline bool Style::has_stroke_width() const {
  return _has_bit(2);
}
inline void Style::clear_stroke_width() {
  stroke_width_ = 1;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Style::stroke_width() const {
  return stroke_width_;
}
inline void Style::set_stroke_width(::google::protobuf::int32 value) {
  _set_bit(2);
  stroke_width_ = value;
}

// -------------------------------------------------------------------

// Point

// required float x = 1;
inline bool Point::has_x() const {
  return _has_bit(0);
}
inline void Point::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline float Point::x() const {
  return x_;
}
inline void Point::set_x(float value) {
  _set_bit(0);
  x_ = value;
}

// required float y = 2;
inline bool Point::has_y() const {
  return _has_bit(1);
}
inline void Point::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline float Point::y() const {
  return y_;
}
inline void Point::set_y(float value) {
  _set_bit(1);
  y_ = value;
}

// -------------------------------------------------------------------

// Line

// required .chart_proto.Point point1 = 1;
inline bool Line::has_point1() const {
  return _has_bit(0);
}
inline void Line::clear_point1() {
  if (point1_ != NULL) point1_->::chart_proto::Point::Clear();
  _clear_bit(0);
}
inline const ::chart_proto::Point& Line::point1() const {
  return point1_ != NULL ? *point1_ : *default_instance_->point1_;
}
inline ::chart_proto::Point* Line::mutable_point1() {
  _set_bit(0);
  if (point1_ == NULL) point1_ = new ::chart_proto::Point;
  return point1_;
}

// required .chart_proto.Point point2 = 2;
inline bool Line::has_point2() const {
  return _has_bit(1);
}
inline void Line::clear_point2() {
  if (point2_ != NULL) point2_->::chart_proto::Point::Clear();
  _clear_bit(1);
}
inline const ::chart_proto::Point& Line::point2() const {
  return point2_ != NULL ? *point2_ : *default_instance_->point2_;
}
inline ::chart_proto::Point* Line::mutable_point2() {
  _set_bit(1);
  if (point2_ == NULL) point2_ = new ::chart_proto::Point;
  return point2_;
}

// -------------------------------------------------------------------

// Rectangle

// required .chart_proto.Point top_left = 1;
inline bool Rectangle::has_top_left() const {
  return _has_bit(0);
}
inline void Rectangle::clear_top_left() {
  if (top_left_ != NULL) top_left_->::chart_proto::Point::Clear();
  _clear_bit(0);
}
inline const ::chart_proto::Point& Rectangle::top_left() const {
  return top_left_ != NULL ? *top_left_ : *default_instance_->top_left_;
}
inline ::chart_proto::Point* Rectangle::mutable_top_left() {
  _set_bit(0);
  if (top_left_ == NULL) top_left_ = new ::chart_proto::Point;
  return top_left_;
}

// required float width = 2;
inline bool Rectangle::has_width() const {
  return _has_bit(1);
}
inline void Rectangle::clear_width() {
  width_ = 0;
  _clear_bit(1);
}
inline float Rectangle::width() const {
  return width_;
}
inline void Rectangle::set_width(float value) {
  _set_bit(1);
  width_ = value;
}

// required float height = 3;
inline bool Rectangle::has_height() const {
  return _has_bit(2);
}
inline void Rectangle::clear_height() {
  height_ = 0;
  _clear_bit(2);
}
inline float Rectangle::height() const {
  return height_;
}
inline void Rectangle::set_height(float value) {
  _set_bit(2);
  height_ = value;
}

// -------------------------------------------------------------------

// Circle

// required .chart_proto.Point center = 1;
inline bool Circle::has_center() const {
  return _has_bit(0);
}
inline void Circle::clear_center() {
  if (center_ != NULL) center_->::chart_proto::Point::Clear();
  _clear_bit(0);
}
inline const ::chart_proto::Point& Circle::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::chart_proto::Point* Circle::mutable_center() {
  _set_bit(0);
  if (center_ == NULL) center_ = new ::chart_proto::Point;
  return center_;
}

// required float radius = 2;
inline bool Circle::has_radius() const {
  return _has_bit(1);
}
inline void Circle::clear_radius() {
  radius_ = 0;
  _clear_bit(1);
}
inline float Circle::radius() const {
  return radius_;
}
inline void Circle::set_radius(float value) {
  _set_bit(1);
  radius_ = value;
}

// -------------------------------------------------------------------

// Polygon

// repeated .chart_proto.Point point = 1;
inline int Polygon::point_size() const {
  return point_.size();
}
inline void Polygon::clear_point() {
  point_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Point >&
Polygon::point() const {
  return point_;
}
inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Point >*
Polygon::mutable_point() {
  return &point_;
}
inline const ::chart_proto::Point& Polygon::point(int index) const {
  return point_.Get(index);
}
inline ::chart_proto::Point* Polygon::mutable_point(int index) {
  return point_.Mutable(index);
}
inline ::chart_proto::Point* Polygon::add_point() {
  return point_.Add();
}

// -------------------------------------------------------------------

// Spline

// repeated .chart_proto.Point point = 1;
inline int Spline::point_size() const {
  return point_.size();
}
inline void Spline::clear_point() {
  point_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Point >&
Spline::point() const {
  return point_;
}
inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Point >*
Spline::mutable_point() {
  return &point_;
}
inline const ::chart_proto::Point& Spline::point(int index) const {
  return point_.Get(index);
}
inline ::chart_proto::Point* Spline::mutable_point(int index) {
  return point_.Mutable(index);
}
inline ::chart_proto::Point* Spline::add_point() {
  return point_.Add();
}

// -------------------------------------------------------------------

// Text

// optional .chart_proto.Point point = 1;
inline bool Text::has_point() const {
  return _has_bit(0);
}
inline void Text::clear_point() {
  if (point_ != NULL) point_->::chart_proto::Point::Clear();
  _clear_bit(0);
}
inline const ::chart_proto::Point& Text::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::chart_proto::Point* Text::mutable_point() {
  _set_bit(0);
  if (point_ == NULL) point_ = new ::chart_proto::Point;
  return point_;
}

// required string text = 2;
inline bool Text::has_text() const {
  return _has_bit(1);
}
inline void Text::clear_text() {
  if (text_ != &_default_text_) {
    text_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Text::text() const {
  return *text_;
}
inline void Text::set_text(const ::std::string& value) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Text::set_text(const char* value) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Text::set_text(const char* value, size_t size) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Text::mutable_text() {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  return text_;
}

// -------------------------------------------------------------------

// Shape

// optional .chart_proto.Line line = 1;
inline bool Shape::has_line() const {
  return _has_bit(0);
}
inline void Shape::clear_line() {
  if (line_ != NULL) line_->::chart_proto::Line::Clear();
  _clear_bit(0);
}
inline const ::chart_proto::Line& Shape::line() const {
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::chart_proto::Line* Shape::mutable_line() {
  _set_bit(0);
  if (line_ == NULL) line_ = new ::chart_proto::Line;
  return line_;
}

// optional .chart_proto.Rectangle rectangle = 2;
inline bool Shape::has_rectangle() const {
  return _has_bit(1);
}
inline void Shape::clear_rectangle() {
  if (rectangle_ != NULL) rectangle_->::chart_proto::Rectangle::Clear();
  _clear_bit(1);
}
inline const ::chart_proto::Rectangle& Shape::rectangle() const {
  return rectangle_ != NULL ? *rectangle_ : *default_instance_->rectangle_;
}
inline ::chart_proto::Rectangle* Shape::mutable_rectangle() {
  _set_bit(1);
  if (rectangle_ == NULL) rectangle_ = new ::chart_proto::Rectangle;
  return rectangle_;
}

// optional .chart_proto.Circle circle = 3;
inline bool Shape::has_circle() const {
  return _has_bit(2);
}
inline void Shape::clear_circle() {
  if (circle_ != NULL) circle_->::chart_proto::Circle::Clear();
  _clear_bit(2);
}
inline const ::chart_proto::Circle& Shape::circle() const {
  return circle_ != NULL ? *circle_ : *default_instance_->circle_;
}
inline ::chart_proto::Circle* Shape::mutable_circle() {
  _set_bit(2);
  if (circle_ == NULL) circle_ = new ::chart_proto::Circle;
  return circle_;
}

// optional .chart_proto.Polygon polygon = 4;
inline bool Shape::has_polygon() const {
  return _has_bit(3);
}
inline void Shape::clear_polygon() {
  if (polygon_ != NULL) polygon_->::chart_proto::Polygon::Clear();
  _clear_bit(3);
}
inline const ::chart_proto::Polygon& Shape::polygon() const {
  return polygon_ != NULL ? *polygon_ : *default_instance_->polygon_;
}
inline ::chart_proto::Polygon* Shape::mutable_polygon() {
  _set_bit(3);
  if (polygon_ == NULL) polygon_ = new ::chart_proto::Polygon;
  return polygon_;
}

// optional .chart_proto.Spline spline = 9;
inline bool Shape::has_spline() const {
  return _has_bit(4);
}
inline void Shape::clear_spline() {
  if (spline_ != NULL) spline_->::chart_proto::Spline::Clear();
  _clear_bit(4);
}
inline const ::chart_proto::Spline& Shape::spline() const {
  return spline_ != NULL ? *spline_ : *default_instance_->spline_;
}
inline ::chart_proto::Spline* Shape::mutable_spline() {
  _set_bit(4);
  if (spline_ == NULL) spline_ = new ::chart_proto::Spline;
  return spline_;
}

// optional .chart_proto.Text text = 8;
inline bool Shape::has_text() const {
  return _has_bit(5);
}
inline void Shape::clear_text() {
  if (text_ != NULL) text_->::chart_proto::Text::Clear();
  _clear_bit(5);
}
inline const ::chart_proto::Text& Shape::text() const {
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::chart_proto::Text* Shape::mutable_text() {
  _set_bit(5);
  if (text_ == NULL) text_ = new ::chart_proto::Text;
  return text_;
}

// optional .chart_proto.Style style = 5;
inline bool Shape::has_style() const {
  return _has_bit(6);
}
inline void Shape::clear_style() {
  if (style_ != NULL) style_->::chart_proto::Style::Clear();
  _clear_bit(6);
}
inline const ::chart_proto::Style& Shape::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::chart_proto::Style* Shape::mutable_style() {
  _set_bit(6);
  if (style_ == NULL) style_ = new ::chart_proto::Style;
  return style_;
}

// optional int32 text_offset = 6;
inline bool Shape::has_text_offset() const {
  return _has_bit(7);
}
inline void Shape::clear_text_offset() {
  text_offset_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 Shape::text_offset() const {
  return text_offset_;
}
inline void Shape::set_text_offset(::google::protobuf::int32 value) {
  _set_bit(7);
  text_offset_ = value;
}

// optional int32 text_length = 7;
inline bool Shape::has_text_length() const {
  return _has_bit(8);
}
inline void Shape::clear_text_length() {
  text_length_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 Shape::text_length() const {
  return text_length_;
}
inline void Shape::set_text_length(::google::protobuf::int32 value) {
  _set_bit(8);
  text_length_ = value;
}

// -------------------------------------------------------------------

// Graphic

// repeated .chart_proto.Shape shape = 1;
inline int Graphic::shape_size() const {
  return shape_.size();
}
inline void Graphic::clear_shape() {
  shape_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Shape >&
Graphic::shape() const {
  return shape_;
}
inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Shape >*
Graphic::mutable_shape() {
  return &shape_;
}
inline const ::chart_proto::Shape& Graphic::shape(int index) const {
  return shape_.Get(index);
}
inline ::chart_proto::Shape* Graphic::mutable_shape(int index) {
  return shape_.Mutable(index);
}
inline ::chart_proto::Shape* Graphic::add_shape() {
  return shape_.Add();
}

// optional float width = 2;
inline bool Graphic::has_width() const {
  return _has_bit(1);
}
inline void Graphic::clear_width() {
  width_ = 0;
  _clear_bit(1);
}
inline float Graphic::width() const {
  return width_;
}
inline void Graphic::set_width(float value) {
  _set_bit(1);
  width_ = value;
}

// optional float height = 3;
inline bool Graphic::has_height() const {
  return _has_bit(2);
}
inline void Graphic::clear_height() {
  height_ = 0;
  _clear_bit(2);
}
inline float Graphic::height() const {
  return height_;
}
inline void Graphic::set_height(float value) {
  _set_bit(2);
  height_ = value;
}

// -------------------------------------------------------------------

// Action

// required string action = 1;
inline bool Action::has_action() const {
  return _has_bit(0);
}
inline void Action::clear_action() {
  if (action_ != &_default_action_) {
    action_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Action::action() const {
  return *action_;
}
inline void Action::set_action(const ::std::string& value) {
  _set_bit(0);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void Action::set_action(const char* value) {
  _set_bit(0);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void Action::set_action(const char* value, size_t size) {
  _set_bit(0);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  action_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Action::mutable_action() {
  _set_bit(0);
  if (action_ == &_default_action_) {
    action_ = new ::std::string;
  }
  return action_;
}

// required int32 width = 3;
inline bool Action::has_width() const {
  return _has_bit(1);
}
inline void Action::clear_width() {
  width_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Action::width() const {
  return width_;
}
inline void Action::set_width(::google::protobuf::int32 value) {
  _set_bit(1);
  width_ = value;
}

// optional int32 repetitions = 2 [default = 1];
inline bool Action::has_repetitions() const {
  return _has_bit(2);
}
inline void Action::clear_repetitions() {
  repetitions_ = 1;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Action::repetitions() const {
  return repetitions_;
}
inline void Action::set_repetitions(::google::protobuf::int32 value) {
  _set_bit(2);
  repetitions_ = value;
}

// optional int32 text_offset = 4;
inline bool Action::has_text_offset() const {
  return _has_bit(3);
}
inline void Action::clear_text_offset() {
  text_offset_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Action::text_offset() const {
  return text_offset_;
}
inline void Action::set_text_offset(::google::protobuf::int32 value) {
  _set_bit(3);
  text_offset_ = value;
}

// optional int32 text_length = 5;
inline bool Action::has_text_length() const {
  return _has_bit(4);
}
inline void Action::clear_text_length() {
  text_length_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Action::text_length() const {
  return text_length_;
}
inline void Action::set_text_length(::google::protobuf::int32 value) {
  _set_bit(4);
  text_length_ = value;
}

// -------------------------------------------------------------------

// Row

// repeated .chart_proto.Action action = 1;
inline int Row::action_size() const {
  return action_.size();
}
inline void Row::clear_action() {
  action_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Action >&
Row::action() const {
  return action_;
}
inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Action >*
Row::mutable_action() {
  return &action_;
}
inline const ::chart_proto::Action& Row::action(int index) const {
  return action_.Get(index);
}
inline ::chart_proto::Action* Row::mutable_action(int index) {
  return action_.Mutable(index);
}
inline ::chart_proto::Action* Row::add_action() {
  return action_.Add();
}

// -------------------------------------------------------------------

// ActionType

// required string name = 1;
inline bool ActionType::has_name() const {
  return _has_bit(0);
}
inline void ActionType::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ActionType::name() const {
  return *name_;
}
inline void ActionType::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ActionType::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ActionType::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionType::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional int32 width = 2 [default = 1];
inline bool ActionType::has_width() const {
  return _has_bit(1);
}
inline void ActionType::clear_width() {
  width_ = 1;
  _clear_bit(1);
}
inline ::google::protobuf::int32 ActionType::width() const {
  return width_;
}
inline void ActionType::set_width(::google::protobuf::int32 value) {
  _set_bit(1);
  width_ = value;
}

// optional .chart_proto.Graphic graphic = 4;
inline bool ActionType::has_graphic() const {
  return _has_bit(2);
}
inline void ActionType::clear_graphic() {
  if (graphic_ != NULL) graphic_->::chart_proto::Graphic::Clear();
  _clear_bit(2);
}
inline const ::chart_proto::Graphic& ActionType::graphic() const {
  return graphic_ != NULL ? *graphic_ : *default_instance_->graphic_;
}
inline ::chart_proto::Graphic* ActionType::mutable_graphic() {
  _set_bit(2);
  if (graphic_ == NULL) graphic_ = new ::chart_proto::Graphic;
  return graphic_;
}

// -------------------------------------------------------------------

// Library

// repeated .chart_proto.ActionType action_type = 1;
inline int Library::action_type_size() const {
  return action_type_.size();
}
inline void Library::clear_action_type() {
  action_type_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::ActionType >&
Library::action_type() const {
  return action_type_;
}
inline ::google::protobuf::RepeatedPtrField< ::chart_proto::ActionType >*
Library::mutable_action_type() {
  return &action_type_;
}
inline const ::chart_proto::ActionType& Library::action_type(int index) const {
  return action_type_.Get(index);
}
inline ::chart_proto::ActionType* Library::mutable_action_type(int index) {
  return action_type_.Mutable(index);
}
inline ::chart_proto::ActionType* Library::add_action_type() {
  return action_type_.Add();
}

// -------------------------------------------------------------------

// Chart

// repeated .chart_proto.Row row = 1;
inline int Chart::row_size() const {
  return row_.size();
}
inline void Chart::clear_row() {
  row_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::chart_proto::Row >&
Chart::row() const {
  return row_;
}
inline ::google::protobuf::RepeatedPtrField< ::chart_proto::Row >*
Chart::mutable_row() {
  return &row_;
}
inline const ::chart_proto::Row& Chart::row(int index) const {
  return row_.Get(index);
}
inline ::chart_proto::Row* Chart::mutable_row(int index) {
  return row_.Mutable(index);
}
inline ::chart_proto::Row* Chart::add_row() {
  return row_.Add();
}

// optional .chart_proto.Library library = 2;
inline bool Chart::has_library() const {
  return _has_bit(1);
}
inline void Chart::clear_library() {
  if (library_ != NULL) library_->::chart_proto::Library::Clear();
  _clear_bit(1);
}
inline const ::chart_proto::Library& Chart::library() const {
  return library_ != NULL ? *library_ : *default_instance_->library_;
}
inline ::chart_proto::Library* Chart::mutable_library() {
  _set_bit(1);
  if (library_ == NULL) library_ = new ::chart_proto::Library;
  return library_;
}

// -------------------------------------------------------------------

// ChartFile

// optional .chart_proto.Library library = 2;
inline bool ChartFile::has_library() const {
  return _has_bit(0);
}
inline void ChartFile::clear_library() {
  if (library_ != NULL) library_->::chart_proto::Library::Clear();
  _clear_bit(0);
}
inline const ::chart_proto::Library& ChartFile::library() const {
  return library_ != NULL ? *library_ : *default_instance_->library_;
}
inline ::chart_proto::Library* ChartFile::mutable_library() {
  _set_bit(0);
  if (library_ == NULL) library_ = new ::chart_proto::Library;
  return library_;
}

// optional string text = 4;
inline bool ChartFile::has_text() const {
  return _has_bit(1);
}
inline void ChartFile::clear_text() {
  if (text_ != &_default_text_) {
    text_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ChartFile::text() const {
  return *text_;
}
inline void ChartFile::set_text(const ::std::string& value) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ChartFile::set_text(const char* value) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ChartFile::set_text(const char* value, size_t size) {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChartFile::mutable_text() {
  _set_bit(1);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  return text_;
}


}  // namespace chart_proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_storage_2fchart_2eproto__INCLUDED
